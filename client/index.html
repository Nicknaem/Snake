<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="assets/favicon.png" type="image/x-icon">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"></meta> 
    <meta name="theme-color" content="#ffffff">
    <title>Snake</title>
    <link rel="manifest" href="./manifest.json"> 
    <script defer>
        if('serviceWorker' in navigator) {
            navigator.serviceWorker
            .register('/sw.js')
            .then(() => { console.log('Service Worker Registered'); })
            .catch(e=>{});
        };
    </script>
    <!-- <script type="module" defer>
        import { io } from "https://cdn.socket.io/4.3.2/socket.io.esm.min.js";
        const socket = io('localhost:3000');
        socket.on('connect', ()=>{
            console.log('connected')
        })
    </script> -->

    <!-- <script src="libs/socket.io.js"></script> -->
    
    <!-- <script defer>
        // Array(100).fill(0).forEach((item,index)=>{console.log(index, String.fromCharCode(index))})
        function connect(){
            let address = document.querySelector('#address');
            if(address){
                let path = '5.'+iptotext(address.value,3);   
                console.log(path)
                let socket = io(path)
            }else{
                let socket = io('http://localhost:3000')
            }
        }
    </script> -->
   
    <link rel="stylesheet" href="./styles/main.css">
</head>

<body>
    <div class="main" id="touch-area">
        <div class="header">
            <div id="top-score">0</div>
            <div id="live-score"></div>
            <div id="buttons-board">
                <button onclick="animateSnake()">toggle animation</button>
                <button onclick="foodSpawnCheck()">check food spawn</button>
            </div>
        </div>
        <div class="game-board">
            <div class="layer-list">
                <div id="layer_1"></div>
            </div>
            <div id="food-list"></div>
            <div id="snake-list">
                <!-- <div id="snake_1"></div> -->
            </div>
        </div>
        <div class="footer">
            <!-- <img onclick="playPause()" src="./assets/pause.svg" width="35" height="35"> -->
            <div onclick="playPause()" class="emoji-btn">‚ñ∂</div>
            <!-- <img onclick="debug()" src="./assets/bug.png" width="32px" height="32px"> -->
            <div onclick="restartGame()" class="emoji-btn">üêç</div>

            <div onclick="colorPalette(this)" class="emoji-btn">üé®</div>
            <div onclick="newLayer()" class="emoji-btn">üìú</div>
            <div onclick="paintMode()" class="emoji-btn">üñå</div>
            <div style="display:none">
                <input id="address" type="text">
                <button onclick="connect()">Connect</button>
            </div>
        </div>
    </div>
</body>
<script>

let paused = false;
function playPause(){
    let snake = Snakes[0];

    if(!paused){
        paused = true;
        clearInterval(snake.interval);
    }else{
        paused = false;
        snake.interval = setInterval(() => {
            snake.updateSnake();
        }, snake.speed);
    }
}

let html = {
    log: (info)=>{
        let log = document.querySelector('.log')
        if(!log){
            document.body.insertAdjacentHTML('afterbegin', `
                <div class="log" onclick="remove(this)" style="position: absolute; width:100vw; height:100vh">
                    ${JSON.stringify(info)}
                    <br>
                </div>
            `)
        }else{
            log.insertAdjacentHTML('beforeend',JSON.stringify(info))
            log.insertAdjacentHTML('beforeend', '<br>')
        }
    }
}
function remove(element){
    element.remove()
}
function debug(){
    // let snake = Snakes[0];
    html.log('foodlist element count: '+foodListDiv.children.length);
    html.log(foodListDiv.children);
    html.log('found food count: ' + document.querySelectorAll('.food').length);
    html.log(document.querySelectorAll('.food'));
}

//================================== static values
let liveScoreDiv = document.getElementById('live-score');
let topScoreDiv = document.getElementById('top-score');
let boardDiv = document.querySelector('.game-board');
let foodListDiv = document.getElementById('food-list');
let snakeListDiv = document.getElementById('snake-list');

//================================== GameConfigurable values
let boardWidth = boardDiv.getBoundingClientRect().width;
let boardHeight = boardDiv.getBoundingClientRect().height; 
let cellSize = 20; 
let bonusApples = 0;
let activeLayerDiv;
// snakeColor

let comments =[
    '·Éõ·Éî·É¢·Éò ·É®·Éî·Éí·Éî·É´·Éö·Éù üòÇ',
    '·Éô·É£·Éì·Éñ·Éî ·Éï·Éò·Éô·Éë·Éò·Éú·Éî üò¨',
    '·Éú·É£ ·Éõ·É≠·Éê·Éõ üç¥üç£',
    '·É†·Éù·É™·Éê ·Éí·É®·Éò·Éê ·É®·Éî·Éú ·É®·Éî·Éú ·Éê·É†·ÉÆ·Éê·É† üç´',
    '·É°·É°·É°ü©∏ü©∏ü©∏',
    '·Éú·Éù·Éù·Éù·Éù·Éù·Éù·Éù·Éù·Éù·Éù·Éù',
    '·Éú·É£ ·Éõ·Éô·Éë·Éî·Éú ·É®·Éî ·Éí·Éï·Éî·Éö·Éù üêç',
    '·Éë·Éê·Éú·É´·Éù ·Éë·Éê·Éú·É´·Éù üòõüòõ',
    '·Éê·Éõ·Éì·Éî·Éú·É°·Éê·É™ ·Éê·É†·Éõ·Éù·Éï·Éî·Éö·Éù·Éì·Éò üòÑ',
]

let foodTypes = [
    '_nitro',
    '_multiple',
    'gold',
    '_purple',
    '_red',
    '_green',
    '_orange',
    'dark',
    'light'
];

let emojiList = [
    ['130','üíä'],
    ['120','üêç'],
    ['100','üèÜ'],
    ['50','‚≠ê'],
    ['0','‚ù§Ô∏è']
]
    
function eyeType(amount){
    for(item of emojiList){
        if(liveScore >= item[0]){
            return item[1]
        }
    }
}

let GameState = {
    snakes: []
};

let topScore = localStorage.getItem('topScore');
if(topScore == 196){
    localStorage.setItem('topScore', 199)
    topScore = 199;
}
let liveScore = 0;
topScoreDiv.innerText = topScore;
liveScoreDiv.innerText = liveScore;

if(topScore){
    topScoreDiv.innerText = topScore;
    bonusApples = Math.floor(topScore/10); 
}

function restartGame(){
    boardDiv.classList.remove('paint-mode');
    if(activeLayerDiv){
        activeLayerDiv.remove();
    }
    activeLayerDiv = null;
    if(topScore > 100 && limitMinutes()){
        alert('üëÄ ·Éõ·Éù·É£·É§·É†·Éó·ÉÆ·Éò·Éö·Éì·Éò ‚ù§Ô∏è‚ù§Ô∏è');
        return;
    }
    snakeListDiv.innerHTML = '';
    foodListDiv.innerHTML = '';
    document.body.classList.remove('dark')
    spawnFood(10);

    Snakes[0] = new Snake()
    // Snakes.push(new Snake());

    Snakes.forEach((snake,index)=>{
        snake.spawnSnake();
        snake.interval = setInterval(() => {
            snake.updateSnake();
        }, snake.speed);
    })
    
}
//timer
//after some time when dead restart game and save user points

function limit(){
    let date = new Date()
    let limitMatch = `${date.getDay()}${date.getHours()}`;
    let limitMatchStored = localStorage.getItem('limitMatch');
    let count = localStorage.getItem('limitCount');
    if(limitMatch === limitMatchStored){
        count++
        localStorage.setItem('limitCount', count);
    }else{
        localStorage.setItem('limitMatch', limitMatch);
        localStorage.setItem('limitCount', 1);
    }
    return count>15
}

function limitMinutes(){
    let date = new Date()
    let limitMatch = `${date.getDay()}`;
    let limitMatchStored = localStorage.getItem('limitDayMatch');

    if(limitMatch === limitMatchStored){
        let startTime = localStorage.getItem('startTime');
        let playTime = localStorage.getItem('playTime');
        if(startTime){
            if(startTime > date.getMinutes){ return false}
            let totalTime = date.getMinutes() - startTime + playTime;
            if( totalTime > 15){
                return true;
            }else{
                localStorage.setItem('playTime',  date.getMinutes() - startTime);
            }
        }else{
            localStorage.setItem('startTime', date.getMinutes())
        }
    }else{
        localStorage.setItem('limitDayMatch', limitMatch);
    }
    return false;
}

function randGridPos(range){
    //because of floor 500 will never be reached so foodX will be max 480   
    let randX = Math.floor(Math.random()*range); 
    return randX - randX%cellSize;
}

/*rules
on light shouldnot spawn light
on dark shouldnot spawn dark 
nitro shouldnot be spawned after 15 length
feature type should be spawned at odd counts no chances needed
shouldnot spawn same feature type
*/

//generate random coords so food is inside the board and not on snake position
function spawnFood(foodAmount){
    // let stop = false;
    // let chance = Math.floor(Math.random()*3)==1;
    let type = foodTypes[Math.floor(Math.random()*foodTypes.length)];

    for(let i=0; i<foodAmount; i++){
        let lastFood
        let bypass = false;

        if(i === foodAmount-1){
            lastFood = true
        }
        if(i==9){
            type = 'nitro'
        }
        if(type === document.body.className){
            spawnFood(1);
            bypass = true
        }
        let foodX = randGridPos(boardWidth)
        let foodY = randGridPos(boardHeight)

        // if foodList matches any snakeBody position re generate random position and try again
        // all snake body positions should be accesed globally, GameState
        GameState.snakes.forEach(snake => {
            snake.forEach((cell)=>{
                if(cell.cellX === foodX && cell.cellY === foodY){
                    spawnFood(1);
                    bypass = true;
                }
            })
        });

        if(!bypass){
            let foodDiv = `
                <div 
                    class="food food-small"
                    type="${lastFood ? type : ''}"
                    style="left:${foodX}; top:${foodY}">
                </div>
            `;
            foodListDiv.insertAdjacentHTML('beforeend', foodDiv);
            setTimeout(() => {
                for( foodDiv of foodListDiv.children){
                    foodDiv.classList.remove('food-small');
                }
            }, 100);
        }
    }
}

class Snake {
    static id = 0;
    constructor(){
        // super(); //when extended from another class

        this.speed = 120;
        this.interval;

        this.snakeDiv;

        this.snakeDirection = 'right';
        this.moveQueue = ['right'];
      
        this.snakeTailDiv; //this field is variable
        this.snakeHeadDiv; //this field is static => always points to same div
        this.snakeNeckDivPos; //position of nth child div in #snake
        this.snakeTailDivPos; //position of nth child div on #snake
      
        this.snakeLength = 3; //can not be set less, 3 is minimum //or it can be less :D
        this.snakeBody = [];
        this.snakeAnimated = 0;
    }

    spawnSnake(){
        Snake.id++;
        let elementX = randGridPos(boardWidth)
        let elementY = randGridPos(boardHeight)

        snakeListDiv.insertAdjacentHTML('beforeend',`<div id='snake_${Snake.id}'></div>`)
        this.snakeDiv = document.getElementById(`snake_${Snake.id}`);

        for(let i = 0; i < this.snakeLength; i++){
            //filling snakeBody with default snake length cells
            this.snakeBody.push(
                { 
                    "cellX": elementX,
                    "cellY": elementY
                }
            )
            //creating snake divCell
            let snakeCell = `
                <div 
                    class="snake-cell"
                    style="left:${elementX}; top:${elementY}">
                </div>
            `;

            this.snakeDiv.insertAdjacentHTML('beforeend', snakeCell);
        }
        //save which child div is TailCell and which child div is NeckCell 
        //positions match array numbering
        this.snakeTailDivPos = 0;
        this.snakeNeckDivPos = this.snakeLength-1;

        this.snakeHeadDiv = this.snakeDiv.children[this.snakeLength-1]; // declare head
        this.snakeHeadDiv.innerHTML=`
            <div id="left-eye" class="eyes"> 
                <div class="eye-ball"></div>
            </div>
            <div id="right-eye" class="eyes"> 
                <div class="eye-ball"></div>
            </div>
            <div id="mouth">
                <div id="tongue"></div>
            </div>
        `
        this.snakeHeadDiv.style.transform = "rotate(270deg)" //rotated to right as default start direcition
        this.snakeHeadDiv.classList.add('snake-head');
    }

    snakeExpand(){
        //add new coordinate to array
        this.snakeBody.unshift(this.snakeBody[0]);

        // and new div to CORRECT POSITION! to represent new cell
        let snakeCell = `
            <div 
                class="snake-cell"
                style="left:${this.snakeBody[0].cellX}; top:${this.snakeBody[0].cellY}">
            </div>
        `;
        if(this.snakeAnimated){
            snakeCell.className = "cells-animated";
        }

        this.snakeDiv.children[this.snakeTailDivPos].insertAdjacentHTML('beforebegin',snakeCell)

        this.snakeLength++;
        // this.snakeTailDivPos = 1;
    }

    snakeTrim(){
        //just trim the part of the snake on self hit would be more fun
    }

    nitro(speed, duration){
        clearInterval(this.interval);

        this.interval = setInterval(() => {
            this.updateSnake();
        }, speed);

        setTimeout(() => {
            clearInterval(this.interval);
            this.interval = setInterval(() => {
                this.updateSnake();
            }, this.speed);
        }, duration);
    }

    detectSelfHit(newPos){
        //checks all snake cells if newPos matches snake tail cell
        for(let i = 0; i < this.snakeBody.length-3; i++){
            if( this.snakeBody[i].cellX === newPos.cellX & this.snakeBody[i].cellY === newPos.cellY ){
                console.log('self hit');
                if(liveScore > topScore){
                    topScore = liveScore;
                    localStorage.setItem('topScore', topScore);
                    topScoreDiv.innerText = topScore;
                }

                clearInterval(this.interval)

                this.snakeHeadDiv.classList.add('head-animation');

                this.snakeHeadDiv.querySelectorAll('.eye-ball').forEach((eyeDiv)=>{
                    setTimeout(() => {
                        eyeDiv.classList.add('eye-close')
                    }, 700);
                    setTimeout(() => {
                        eyeDiv.innerText = eyeType();
                        eyeDiv.classList.remove('eye-close');
                        eyeDiv.classList.add('eye-open');
                        this.snakeHeadDiv.onclick = restartGame;
                    }, 900);
                })
                setTimeout(() => {
                    this.snakeHeadDiv.insertAdjacentHTML('beforeend',`
                        <div 
                            onclick="restartGame()"
                            class="comment">
                            ${comments[Math.floor(Math.random() * comments.length-1) + 1]}
                        </div>
                    `)
                }, 900);

                // if(limit()){
                //     let date = new Date()
                //     alert(`·É£·Éô·Éï·Éî 15 ·ÉØ·Éî·É† ·É°·É™·Éê·Éì·Éî üòÇ ·É™·É£·Éì·Éê·Éì ·Éê·É† ·Éí·Éê·ÉÆ·Éì·Éî üòÑ‚ù§Ô∏è ${61 - date.getMinutes()} ·É¨·É£·Éó·É®·Éò ·É®·Éî·Éí·Éî·É®·Éï·Éî·Éë·Éò üòÅ`);
                // }
                return;

                // document.querySelector(`#snake_1 > div:nth-child(${this.snakeHeadDivPos})`).style.boxShadow = "0px 0px 15px rgba(0,0,0,0.9)";
                //or eat tail and coninue playing, sounds more fun
            }
        }
    }

    //detectSnakeHit ooouhh shiiit

    detectFoodHit(newPos){
        //checks if snake hit the foodCell
        Array.from(foodListDiv.children).forEach((foodDiv,index)=>{
            if(parseInt(foodDiv.style.top,10) == newPos.cellY && parseInt(foodDiv.style.left,10) === newPos.cellX){
                switch(foodDiv.getAttribute('type')){
                    case 'nitro':
                        this.nitro(20,3000);
                    break;
                    case 'gold':
                        spawnFood(6)
                    break;
                    case 'purple':
                        this.snakeDiv.setAttribute('color', 'purple')
                    break;
                    case 'red':
                        this.snakeDiv.setAttribute('color', 'red')
                    break;
                    case 'green':
                        this.snakeDiv.setAttribute('color', 'green')
                    break;
                    case 'orange':
                        this.snakeDiv.setAttribute('color', 'orange')
                    break;
                    case 'dark':
                        document.body.setAttribute('theme', 'dark')
                        document.querySelector('[name="theme-color"]').setAttribute('content','#000000')
                    break;
                    case 'tin':
                        document.querySelector('[name="theme-color"]').setAttribute('content','#fd267a')
                        document.body.setAttribute('theme', 'dark')
                    break;
                    case 'light':
                        document.body.setAttribute('theme', 'light')
                    break;
                }

                //if only one foodDiv left spawn new
                if(foodListDiv.children.length==1){
                    spawnFood(3);
                }
                foodDiv.remove(); 
                this.snakeExpand()

                //update snakes respective score
                liveScore = this.snakeLength-3
                liveScoreDiv.innerText = liveScore;
            }
        })

        if(liveScore > 30){
            document.body.classList.add('dark')
        }

    }

    moveSnake(){
        //set new snakeDirection and rotate head
        switch(this.moveQueue[0]){
            case 'left':
                if(this.snakeDirection != "right"){
                    this.snakeDirection = this.moveQueue[0]
                    this.snakeHeadDiv.style.transform = "rotate(90deg)"
                }
            break;
            case 'right':
                if(this.snakeDirection != "left"){
                    this.snakeDirection = this.moveQueue[0]
                    this.snakeHeadDiv.style.transform = "rotate(270deg)"
                }
            break;
            case 'up':
                if(this.snakeDirection != "down"){
                    this.snakeDirection = this.moveQueue[0]
                    this.snakeHeadDiv.style.transform = "rotate(180deg)"
                }
            break;
            case 'down':
                if(this.snakeDirection != "up"){
                    this.snakeDirection = this.moveQueue[0]
                    this.snakeHeadDiv.style.transform = "rotate(0deg)"
                }
            break;
        }

        //calculate new position
        let newPos;
        switch(this.snakeDirection){
            case 'left':
                newPos = { 
                    "cellX": this.snakeBody[this.snakeBody.length-1].cellX - cellSize,
                    "cellY": this.snakeBody[this.snakeBody.length-1].cellY 
                }
            break;
            case 'right':
                newPos = { 
                    "cellX": this.snakeBody[this.snakeBody.length-1].cellX + cellSize,
                    "cellY": this.snakeBody[this.snakeBody.length-1].cellY 
                }
            break;
            case 'up':
                newPos = { 
                    "cellX": this.snakeBody[this.snakeBody.length-1].cellX,
                    "cellY": this.snakeBody[this.snakeBody.length-1].cellY - cellSize 
                }
            break;
            case 'down':
                newPos = { 
                    "cellX": this.snakeBody[this.snakeBody.length-1].cellX,
                    "cellY": this.snakeBody[this.snakeBody.length-1].cellY + cellSize
                }
            break;
           
        }

        //check if newPos goes out of boundary
        if(newPos.cellX >= boardWidth){
            newPos.cellX -= boardWidth;
        }
        if(newPos.cellX < 0){
            newPos.cellX = boardWidth + newPos.cellX; //"+" because cellX is now negative number;
        }
        if(newPos.cellY >= boardHeight){
            newPos.cellY -= boardHeight;
        }
        if(newPos.cellY < 0){
            newPos.cellY = boardHeight + newPos.cellY; //"+" because cellY is now negative number;
        }

        //Moving snake, Visual update //Method:4
        //Last cellDiv to current headDivPosition and current headDiv to newPosition

        //get access to tailDiv
        this.snakeTailDiv = this.snakeDiv.children[this.snakeTailDivPos]; 
        //move tailDiv to Head position => it will become neck
        this.snakeTailDiv.style.left = this.snakeHeadDiv.style.left;
        this.snakeTailDiv.style.top = this.snakeHeadDiv.style.top;
        //move headDiv to newPos
        this.snakeHeadDiv.style.left = newPos.cellX;
        this.snakeHeadDiv.style.top = newPos.cellY;

        //update headPos and tailPos tracking => here tail becomes neck
        this.snakeNeckDivPos = this.snakeTailDivPos;
        if(this.snakeTailDivPos === this.snakeLength-2){ //-2 because we dont track head, -1 is the head position in array
            this.snakeTailDivPos = 0;
        }else{
            this.snakeTailDivPos++;
        }; 

        //detect food hit
        this.detectFoodHit(newPos);

        //updating coordinates array
        this.snakeBody.push(newPos)
        this.snakeBody.shift()

        this.detectSelfHit(newPos);

        GameState.snakes[Snake.id] = this.snakeBody
    }

    updateSnake(){
        // main function that will update game at every tick
        this.moveSnake();
    }
}

//================================================================== initialisation    
    // const snakeOne = new Snake();
    // const snakeTwo = new Snake();
    // snakeOne.spawnSnake();
    // snakeTwo.spawnSnake();

    // var Snakes = [new Snake()]
    // Snakes.push(new Snake());

    // Snakes.forEach((snake,index)=>{
    //     snake.spawnSnake();
    //     snake.interval = setInterval(() => {
    //         snake.updateSnake();
    //     }, snake.speed);
    // })
    var Snakes = [];
    restartGame();

//change speed function to re initialize intervals
    // clearInterval( Snakes[0].interval );
    // Snakes[0].speed = 50;

    // Snakes.forEach((snake,index)=>{
    //     snake.interval = setInterval(() => {
    //         snake.updateSnake();
    //     }, snake.speed);
    // })

    

    // ============================================================ button test functions
    function animateSnake(){
        game.snakeAnimated = !game.snakeAnimated;
        [...document.querySelectorAll('[id*=snake] > div')].forEach((item)=>{
            item.classList.toggle('cells-animated');
        });
    }

    var interval
    function foodSpawnCheck(){
        if(interval === undefined){
            interval = setInterval(() => {
                game.spawnFood(4);
                foodSpawn = undefined;
            }, 50);
        }else{
            clearInterval(interval); 
            interval = undefined;
        }
        
    }

    //============================================================ controller functions
    
    function rotateSnake(direction){
        Snakes[0].moveQueue.push(direction);
        Snakes[0].moveQueue.shift();
    }

    document.addEventListener('keydown', (event)=>{
        switch(event.key){
            case 'ArrowLeft':
                rotateSnake('left')
            break;
            case 'ArrowRight':
                rotateSnake('right')
            break;
            case 'ArrowUp':
                rotateSnake('up')
            break;
            case 'ArrowDown':
                rotateSnake('down')
            break;
        };
        // Snakes[0].updateSnake(game);
    })

    //======================================================== manual control snakes wsad and arrows
    // document.addEventListener('keydown', (event)=>{

    //     switch(event.key){
    //         case 'ArrowLeft':
    //             Snakes[0].moveQueue.push('left')
    //             Snakes[0].moveQueue.shift()
    //         break;
    //         case 'ArrowRight':

    //             Snakes[0].moveQueue.push('right')
    //             Snakes[0].moveQueue.shift()
    //         break;
    //         case 'ArrowUp':
    //             Snakes[0].moveQueue.push('up')
    //             Snakes[0].moveQueue.shift()
    //         break;
    //         case 'ArrowDown':
    //             Snakes[0].moveQueue.push('down')
    //             Snakes[0].moveQueue.shift()
    //         break;
    //     };
    //     if(Snakes[1]!=undefined){
    //         switch(event.key){
    //         case 'a':
    //             Snakes[1].moveQueue.push('left')
    //             Snakes[1].moveQueue.shift()
    //         break;
    //         case 'd':
    //             Snakes[1].moveQueue.push('right')
    //             Snakes[1].moveQueue.shift()
    //         break;
    //         case 'w':
    //             Snakes[1].moveQueue.push('up')
    //             Snakes[1].moveQueue.shift()
    //         break;
    //         case 's':
    //             Snakes[1].moveQueue.push('down')
    //             Snakes[1].moveQueue.shift()
    //         break;
    //     };
    //     }
    // })
//================================ painter ============================
let layerListDiv = document.querySelector('.layer-list');
// let activeLayerDiv;
let activeBlock = 'grass'

function insertHTML(target, template, position='beforeend'){
    target.insertAdjacentHTML(position, template);
    switch(position){
        case 'beforeend': return target.lastElementChild; break;
        case 'afterbegin': return target.firstElementChild; break;
        case 'afterend': return target.nextElementSibling; break;
        case 'beforebegin': return target.previousElementSibling; break;
    }
}

let blockList = [
    'grass',
    'wood',
    'leaves',
    'water',
    'dirt',
    'apple',
    'white',
]

function chooseBlock(element){
    activeBlock = element.getAttribute('type')
}

function colorPalette(element){
    let test = document.querySelector('.palette-container');
    if(test){
        test.classList.remove('palette-animated');
        setTimeout(() => {
            test.remove();
        }, 300);
        return
    }
    let paletteDiv = insertHTML(element, `
        <div class="palette-container"></div>
    `)

    setTimeout(() => {
        paletteDiv.classList.add('palette-animated');
        insertHTML(paletteDiv, blockList.map((block)=>{
            return `<div class="block-btn" onclick="chooseBlock(this)" type="${block}"></div>`
        }).join(''))
    }, 100);
}

function paintMode(){
    snakeListDiv.innerHTML = '';
    foodListDiv.innerHTML = '';
    activeBlock = 'dirt'
    boardDiv.classList.add('paint-mode');
    newLayer();    
}
function newLayer(){
    console.log(layerListDiv)
    activeLayerDiv = insertHTML(layerListDiv, `
        <div id="new_layer"></div>
    `)
}

function paint(x,y){
    let correctX = x-x%cellSize 
    let correctY = y-y%cellSize

    if(activeLayerDiv.querySelector(`[style='left:${correctX}; top:${correctY}'][type='${activeBlock}']`)){
        console.log('already exists')
        return;
    }

    let sides = [
        [correctX-cellSize, correctY, 'side-left','side-right'],
        [correctX+cellSize, correctY, 'side-right', 'side-left'],
        [correctX, correctY-cellSize, 'side-top', 'side-bottom'],
        [correctX, correctY+cellSize, 'side-bottom', 'side-top']
    ]

    let corners = [
        [correctX-cellSize, correctY-cellSize, 'corner-top-left', 'corner-bottom-right'],
        [correctX+cellSize, correctY-cellSize, 'corner-top-right', 'corner-bottom-left'],
        [correctX-cellSize, correctY+cellSize, 'corner-bottom-left', 'corner-top-right'],
        [correctX+cellSize, correctY+cellSize, 'corner-bottom-right', 'corner-top-left']
    ]

    let sideClassList = [];
    sides.forEach((coord)=>{
        let sideBlock = activeLayerDiv.querySelector(`[style='left:${coord[0]}; top:${coord[1]}'][type='${activeBlock}']`);
        if(sideBlock){
            sideClassList.push(coord[2]);
            sideBlock.classList.add(coord[3])
        }
    })

    let cornerClassList = [];
    corners.forEach((coord)=>{
        let cornerBlock = activeLayerDiv.querySelector(`[style='left:${coord[0]}; top:${coord[1]}'][type='${activeBlock}']`);
        if(cornerBlock){
            cornerClassList.push(coord[2]);
            cornerBlock.classList.add(coord[3])
        }
    })

    let blockDiv = insertHTML(activeLayerDiv, `
        <div 
            class="block block-small ${sideClassList.join(' ')} ${cornerClassList.join(' ')}"
            type="${activeBlock}"
            style="left:${correctX}; top:${correctY}">
        </div>
    `)
    setTimeout(() => {
        blockDiv.classList.remove('block-small');
    }, 10);
}
//================================ swipe controller ====================

let touchArea = document.getElementById("touch-area");

//Initial mouse X and Y positions are 0

let mouseX,
  initialX = 0;
let mouseY,
  initialY = 0;
let isSwiped;

//Events for touch and mouse
let events = {
  mouse: {
    down: "mousedown",
    move: "mousemove",
    up: "mouseup",
  },
  touch: {
    down: "touchstart",
    move: "touchmove",
    up: "touchend",
  },
};

let deviceType = "";

//Detect touch device

const isTouchDevice = () => {
  try {
    //We try to create TouchEvent (it would fail for desktops and throw error)
    document.createEvent("TouchEvent");
    deviceType = "touch";
    return true;
  } catch (e) {
    deviceType = "mouse";
    return false;
  }
};

//Get left and top of touchArea
let rectLeft = touchArea.getBoundingClientRect().left;
let rectTop = touchArea.getBoundingClientRect().top;
let boardLeft = boardDiv.getBoundingClientRect().left
let boardTop = boardDiv.getBoundingClientRect().top

//Get Exact X and Y position of mouse/touch
const getXY = (e) => {
  mouseX = (!isTouchDevice() ? e.pageX : e.touches[0].pageX) - rectLeft;
  mouseY = (!isTouchDevice() ? e.pageY : e.touches[0].pageY) - rectTop;
};

isTouchDevice();

//Start Swipe
touchArea.addEventListener(events[deviceType].down, (event) => {
  isSwiped = true;
  //Get X and Y Position
  getXY(event);
  initialX = mouseX;
  initialY = mouseY;
  
  //todo should also restrict after right bottom corner
  if(activeLayerDiv && mouseX > boardLeft && mouseY > boardTop){
      paint(mouseX-boardLeft, mouseY-boardTop)
  }
});

//Mousemove / touchmove
touchArea.addEventListener(events[deviceType].move, (event) => {
  if (!isTouchDevice()) {
    event.preventDefault();
  }
  if (isSwiped) {
    getXY(event);
    let diffX = mouseX - initialX;
    let diffY = mouseY - initialY;
    if (Math.abs(diffY) > Math.abs(diffX)) {
      rotateSnake(diffY > 0 ? "down" : "up");
    } else {
      rotateSnake(diffX > 0 ? "right" : "left");
    }
    if(activeLayerDiv && mouseX > boardLeft && mouseY > boardTop){
      paint(mouseX-boardLeft, mouseY-boardTop)
    }
  }
});

//Stop Drawing
touchArea.addEventListener(events[deviceType].up, () => {
  isSwiped = false;
});

touchArea.addEventListener("mouseleave", () => {
  isSwiped = false;
});

window.onload = () => {
  isSwiped = false;
};

</script>
</html>